"""
This module implements Reservation class.
It is a concrete class and can directly initialize in the app.

Business Logic:
    - id is autogenerated and cannot be edited.
    - Having a InsuranceTier is mandatory.
    - Invoice is automatically created on reservation creation with PENDING status.
    - Total price is calculated and cannot be modified.
    - PricingStrategy is created on initialization and cannot be modified.
    - Total price is calculated automatically with any change in reservation properties.

Author: Peyman Khodabandehlouei
Date: 07-11-2025
"""

import uuid
from datetime import date
from typing import Optional, TYPE_CHECKING

from schemas.domain import ReservationStatus
from core import ReturnDateBeforePickupDateError
from core.pricing_calculator import calculate_total_price, determine_pricing_strategy

if TYPE_CHECKING:
    from core import ClockService
    from domain.user import Customer
    from domain.branch import Branch
    from domain.vehicle import Vehicle
    from domain.pricing import PricingStrategy
    from domain.reservation import AddOn, Invoice, InsuranceTier


class Reservation:
    """
    Concrete class representing a reservation in the application.
    This class can be directly initialized and used during application runtime.

    Args:
        status (ReservationStatus): Status of the reservation.
        creator (Customer): Customer making the reservation.
        vehicle (Vehicle): Vehicle reserved.
        add_ons (Optional[List[AddOn]]): List of add-ons included in the reservation.
        insurance_tier (InsuranceTier): Insurance tier used in the reservation.
        pickup_branch (Branch): Branch where the vehicle will be picked up.
        return_branch (Branch): Branch where the vehicle will be returned.
        pickup_date (date): Date when the vehicle will be picked up.
        return_date (date): Date when the vehicle will be returned.
        reservation_id (Optional[str]): ID of the reservation.
        clock (Optional[ClockService]): Clock service used for time-based calculations.

    Raises:
        TypeError: If any parameter has an incorrect type.
        ValueError: If dates violate business constraints (pickup_date > return_date or in the past).
    """

    def __init__(
        self,
        status: ReservationStatus,
        creator: "Customer",
        vehicle: "Vehicle",
        insurance_tier: "InsuranceTier",
        pickup_branch: "Branch",
        return_branch: "Branch",
        pickup_date: date,
        return_date: date,
        add_ons: Optional[list["AddOn"]] = None,
        reservation_id: Optional[str] = None,
        total_price: Optional[float] = None,
        invoice: Optional["Invoice"] = None,
        clock: Optional["ClockService"] = None,
    ) -> None:
        """Constructor method for Reservation class"""

        # Add dynamic clock service
        from core import SystemClock

        self._clock = clock or SystemClock()

        # Validate status
        if not isinstance(status, ReservationStatus):
            raise TypeError("status must be an instance of ReservationStatus enum.")

        # Validate creator
        from domain.user import Customer

        if not isinstance(creator, Customer):
            raise TypeError("creator must be an instance of Customer class.")

        # Validate vehicle
        from domain.vehicle import Vehicle

        if not isinstance(vehicle, Vehicle):
            raise TypeError("vehicle must be an instance of Vehicle class.")

        # Validate insurance tier
        from domain.reservation import InsuranceTier

        if not isinstance(insurance_tier, InsuranceTier):
            raise TypeError(
                "insurance_tier must be an instance of InsuranceTier class."
            )

        # Validate pickup and return branch
        from domain.branch import Branch

        if not isinstance(pickup_branch, Branch):
            raise TypeError("pickup_branch must be an instance of Branch class.")
        if not isinstance(return_branch, Branch):
            raise TypeError("return_branch must be an instance of Branch class.")

        # Validate pickup and return dates
        if not isinstance(pickup_date, date):
            raise TypeError("pickup_date must be an instance of date class.")
        if not isinstance(return_date, date):
            raise TypeError("return_date must be an instance of date class.")
        if pickup_date > return_date:
            raise ReturnDateBeforePickupDateError(return_date, pickup_date)
        if pickup_date < self._clock.today():
            raise ValueError("pickup_date cannot be in the past.")

        # Validate addons
        if add_ons is None:
            add_ons = []

        if not isinstance(add_ons, list):
            raise TypeError("add_ons must be a list of AddOn instances.")
        from domain.reservation import AddOn

        if not all(isinstance(add_on, AddOn) for add_on in add_ons):
            raise TypeError("All add-ons must be instances of AddOn class.")

        # Validate id
        if reservation_id is not None and not isinstance(reservation_id, str):
            raise TypeError("reservation_id must be a string.")
        if reservation_id == "":
            raise ValueError("reservation_id cannot be empty.")

        # Assign values
        from domain.reservation import Invoice
        from domain.pricing import PricingStrategy

        self.__id = reservation_id if reservation_id is not None else str(uuid.uuid4())
        self.__status = status
        self.__creator = creator
        self.__vehicle = vehicle
        self.__insurance_tier = insurance_tier
        self.__pickup_branch = pickup_branch
        self.__return_branch = return_branch
        self.__pricing_strategy = PricingStrategy(
            customer=creator
        )  # Adjust pricing strategy dynamically
        self.__pickup_date = pickup_date
        self.__return_date = return_date
        self.__add_ons = add_ons.copy()
        # Calculate price
        if total_price is not None:
            self.__total_price = total_price
        else:
            strategy_type = determine_pricing_strategy(len(creator.reservations))

            addon_prices = [addon.price_per_day for addon in add_ons]

            self.__total_price = calculate_total_price(
                vehicle_price_per_day=vehicle.price_per_day,
                insurance_price_per_day=insurance_tier.price_per_day,
                addon_prices_per_day=addon_prices,
                pickup_date=pickup_date,
                return_date=return_date,
                strategy_type=strategy_type,
            )
        # Add dynamic invoice
        if invoice is not None:
            self.__invoice = invoice
        else:
            self.__invoice = Invoice(creator, self)

    @property
    def id(self) -> str:
        """
        Getter for id property.

        Note: ID is auto-generated and immutable. Cannot be modified after creation.
        """
        return self.__id

    @property
    def status(self) -> ReservationStatus:
        """Getter for status property."""
        return self.__status.value

    @status.setter
    def status(self, status: ReservationStatus) -> None:
        """
        Setter for status property.

        Args:
            status (ReservationStatus): New reservation status.

        Raises:
            TypeError: If status is not a ReservationStatus enum.
        """
        if not isinstance(status, ReservationStatus):
            raise TypeError("status must be an instance of ReservationStatus enum.")

        self.__status = status

    @property
    def creator(self) -> "Customer":
        """Getter for creator property."""
        return self.__creator

    @creator.setter
    def creator(self, creator: "Customer") -> None:
        """
        Setter for creator property.

        Args:
            creator (Customer): New customer creator.

        Raises:
            TypeError: If creator is not a Customer instance.
        """
        from domain.user import Customer

        if not isinstance(creator, Customer):
            raise TypeError("creator must be an instance of Customer class.")

        self.__creator = creator

    @property
    def vehicle(self) -> "Vehicle":
        """Getter for vehicle property."""
        return self.__vehicle

    @vehicle.setter
    def vehicle(self, vehicle: "Vehicle") -> None:
        """
        Setter for vehicle property.

        Automatically recalculates total price when vehicle changes.

        Args:
            vehicle (Vehicle): New vehicle for the reservation.

        Raises:
            TypeError: If vehicle is not a Vehicle instance.
        """
        from domain.vehicle import Vehicle

        if not isinstance(vehicle, Vehicle):
            raise TypeError("vehicle must be an instance of Vehicle class.")

        self.__vehicle = vehicle
        # Recalculate total price
        self.__total_price = self.__pricing_strategy.calculate_price(
            vehicle=self.__vehicle,
            insurance_tier=self.__insurance_tier,
            pickup_date=self.__pickup_date,
            return_date=self.__return_date,
            add_ons=self.__add_ons,
        )

    @property
    def insurance_tier(self) -> "InsuranceTier":
        """Getter for insurance_tier property."""
        return self.__insurance_tier

    @insurance_tier.setter
    def insurance_tier(self, insurance_tier: "InsuranceTier") -> None:
        """
        Setter for insurance_tier property.

        Automatically recalculates total price when insurance tier changes.

        Args:
            insurance_tier (InsuranceTier): New insurance tier.

        Raises:
            TypeError: If insurance_tier is not an InsuranceTier instance.
        """
        from domain.reservation import InsuranceTier

        if not isinstance(insurance_tier, InsuranceTier):
            raise TypeError(
                "insurance_tier must be an instance of InsuranceTier class."
            )

        self.__insurance_tier = insurance_tier
        # Recalculate total price
        self.__total_price = self.__pricing_strategy.calculate_price(
            vehicle=self.__vehicle,
            insurance_tier=self.__insurance_tier,
            pickup_date=self.__pickup_date,
            return_date=self.__return_date,
            add_ons=self.__add_ons,
        )

    @property
    def invoice(self) -> "Invoice":
        """Getter for invoice property."""
        return self.__invoice

    @property
    def pickup_branch(self) -> "Branch":
        """Getter for pickup_branch property."""
        return self.__pickup_branch

    @pickup_branch.setter
    def pickup_branch(self, pickup_branch: "Branch") -> None:
        """
        Setter for pickup_branch property.

        Args:
            pickup_branch (Branch): New pickup branch.

        Raises:
            TypeError: If pickup_branch is not a Branch instance.
        """
        from domain.branch import Branch

        if not isinstance(pickup_branch, Branch):
            raise TypeError("pickup_branch must be an instance of Branch class.")

        self.__pickup_branch = pickup_branch

    @property
    def return_branch(self) -> "Branch":
        """Getter for return_branch property."""
        return self.__return_branch

    @return_branch.setter
    def return_branch(self, return_branch: "Branch") -> None:
        """
        Setter for return_branch property.

        Args:
            return_branch (Branch): New return branch.

        Raises:
            TypeError: If return_branch is not a Branch instance.
        """
        from domain.branch import Branch

        if not isinstance(return_branch, Branch):
            raise TypeError("return_branch must be an instance of Branch class.")

        self.__return_branch = return_branch

    @property
    def pickup_date(self) -> date:
        """Getter for pickup_date property."""
        return self.__pickup_date

    @pickup_date.setter
    def pickup_date(self, pickup_date: date) -> None:
        """
        Setter for pickup_date property.

        Automatically recalculates total price when pickup date changes.

        Args:
            pickup_date (date): New pickup date.

        Raises:
            TypeError: If pickup_date is not a date instance.
            ValueError: If pickup_date is after return_date or in the past.
        """
        if not isinstance(pickup_date, date):
            raise TypeError("pickup_date must be an instance of date class.")
        if pickup_date > self.__return_date:
            raise ReturnDateBeforePickupDateError(self.__return_date, pickup_date)
        if pickup_date < self._clock.today():
            raise ValueError("pickup_date cannot be in the past.")

        self.__pickup_date = pickup_date
        # Recalculate total price
        self.__total_price = self.__pricing_strategy.calculate_price(
            vehicle=self.__vehicle,
            insurance_tier=self.__insurance_tier,
            pickup_date=self.__pickup_date,
            return_date=self.__return_date,
            add_ons=self.__add_ons,
        )

    @property
    def return_date(self) -> date:
        """Getter for return_date property."""
        return self.__return_date

    @return_date.setter
    def return_date(self, return_date: date) -> None:
        """
        Setter for return_date property.

        Automatically recalculates total price when return date changes.

        Args:
            return_date (date): New return date.

        Raises:
            TypeError: If return_date is not a date instance.
            ValueError: If return_date is before pickup_date.
        """
        if not isinstance(return_date, date):
            raise TypeError("return_date must be an instance of date class.")
        if return_date < self.__pickup_date:
            raise ValueError("return_date must be after or equal to pickup_date.")

        self.__return_date = return_date
        # Recalculate total price
        self.__total_price = self.__pricing_strategy.calculate_price(
            vehicle=self.__vehicle,
            insurance_tier=self.__insurance_tier,
            pickup_date=self.__pickup_date,
            return_date=self.__return_date,
            add_ons=self.__add_ons,
        )

    @property
    def add_ons(self) -> list["AddOn"]:
        """Getter for add_ons property."""
        return self.__add_ons.copy()

    @add_ons.setter
    def add_ons(self, add_ons: list["AddOn"]) -> None:
        """
        Setter for add_ons property.

        Automatically recalculates total price when add-ons change.

        Args:
            add_ons (list[AddOn]): New list of add-ons.

        Raises:
            TypeError: If add_ons is not a list or contains non-AddOn instances.
        """
        if not isinstance(add_ons, list):
            raise TypeError("add_ons must be a list of AddOn instances.")

        from domain.reservation import AddOn

        if not all(isinstance(add_on, AddOn) for add_on in add_ons):
            raise TypeError("All add-ons must be instances of AddOn class.")

        self.__add_ons = add_ons.copy()
        # Recalculate total price
        self.__total_price = self.__pricing_strategy.calculate_price(
            vehicle=self.__vehicle,
            insurance_tier=self.__insurance_tier,
            pickup_date=self.__pickup_date,
            return_date=self.__return_date,
            add_ons=self.__add_ons,
        )

    @property
    def pricing_strategy(self) -> "PricingStrategy":
        """
        Getter for pricing property.

        Note: PricingStrategy is created on initialization and cannot be modified.
        """
        return self.__pricing_strategy

    @property
    def total_price(self) -> float:
        """
        Getter for total_price property.

        Note: Total price is calculated automatically and cannot be modified directly.
        It updates automatically when vehicle, insurance_tier, dates, or add_ons change.
        """
        return self.__total_price

    def has_addon(self, addon_id: str) -> bool:
        """
        Check if an add-on exists in the reservation.

        Args:
            addon_id (str): The unique ID of the add-on to search for.

        Returns:
            bool: True if the add-on is found, False otherwise.

        Raises:
            TypeError: If addon_id is not a string.
            ValueError: If addon_id is empty.
        """
        if not isinstance(addon_id, str):
            raise TypeError("addon_id must be a string.")
        if not addon_id:
            raise ValueError("addon_id cannot be empty.")

        return any(addon.id == addon_id for addon in self.__add_ons)

    def add_addon(self, addon: "AddOn") -> None:
        """
        Add a new add-on to the reservation.

        Automatically recalculates total price after adding the add-on.

        Args:
            addon (AddOn): The add-on to add to the reservation.

        Raises:
            TypeError: If addon is not an AddOn instance.
            ValueError: If the add-on already exists in the reservation.
        """
        from domain.reservation import AddOn

        if not isinstance(addon, AddOn):
            raise TypeError("addon must be an instance of AddOn class.")

        if any(existing_addon.id == addon.id for existing_addon in self.__add_ons):
            raise ValueError("Add-on already exists in the reservation.")

        self.__add_ons.append(addon)

        # Recalculate total price
        self.__total_price = self.__pricing_strategy.calculate_price(
            vehicle=self.__vehicle,
            insurance_tier=self.__insurance_tier,
            pickup_date=self.__pickup_date,
            return_date=self.__return_date,
            add_ons=self.__add_ons,
        )

    def remove_addon(self, addon_id: str) -> None:
        """
        Remove an add-on from the reservation.

        Automatically recalculates total price after removing the add-on.

        Args:
            addon_id (str): The unique ID of the add-on to remove.

        Raises:
            TypeError: If addon_id is not a string.
            ValueError: If addon_id is empty or add-on is not found.
        """
        if not isinstance(addon_id, str):
            raise TypeError("addon_id must be a string.")
        if not addon_id:
            raise ValueError("addon_id cannot be empty.")

        if not self.has_addon(addon_id):
            raise ValueError(
                "Add-on with the given ID is not found in the reservation."
            )

        self.__add_ons = [addon for addon in self.__add_ons if addon.id != addon_id]

        # Recalculate total price
        self.__total_price = self.__pricing_strategy.calculate_price(
            vehicle=self.__vehicle,
            insurance_tier=self.__insurance_tier,
            pickup_date=self.__pickup_date,
            return_date=self.__return_date,
            add_ons=self.__add_ons,
        )

    def __str__(self):
        """String representation of the Reservation object."""
        return f"Reservation(id={self.id}, status={self.status}, creator={self.creator}, vehicle={self.vehicle}, insurance_tier={self.insurance_tier}, pickup_branch={self.pickup_branch}, return_branch={self.return_branch}, pickup_date={self.pickup_date}, return_date={self.return_date}, add_ons={self.add_ons}, total_price={self.total_price})"
