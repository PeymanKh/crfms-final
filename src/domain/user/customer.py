"""
This module implements Customer class.
It is a concrete class and can directly initialize in the app.

Business Logic:
    - id is autogenerated and cannot be edited.
    - Customer can pay only for approved reservations.

Author: Peyman Khodabandehlouei
Date: 30-10-2025
"""

from datetime import date
from typing import Any, Optional, List, TYPE_CHECKING

from domain.user import BaseUser
from schemas.entities import Gender, ReservationStatus, VehicleStatus, InvoiceStatus
from core import (
    VehicleNotAvailableError,
    ReservationNotFoundError,
    InvalidReservationStatusForCancellationError,
    PaymentRequiredForPickupError,
    ReservationNotApprovedError,
)

if TYPE_CHECKING:
    from core import ClockService
    from domain.rental import Rental
    from domain.branch import Branch
    from domain.vehicle import Vehicle
    from schemas.entities import RentalCharges
    from domain.reservation import AddOn, Reservation, InsuranceTier


class Customer(BaseUser):
    """
    Concrete class representing a customer in the application.

    Args:
        first_name (str): First name of the employee.
        last_name (str): Last name of the employee.
        gender (Gender): Gender of the employee (Gender enum).
        birth_date (date): Birth date of the employee (must be >= 18 years ago).
        email (EmailStr): Email address of the employee.
        address (str): Home address of the employee.
        phone_number (str): Phone number of the employee.
        reservations (Reservation): Reservations made by the customer.
        rentals (Rental): Rentals made by the customer.
        user_id (Optional[str]): ID of the customer.
    """

    def __init__(
        self,
        first_name: str,
        last_name: str,
        gender: Gender,
        birth_date: date,
        email: str,
        address: str,
        phone_number: str,
        reservations: Optional[List["Reservation"]] = None,
        rentals: Optional[List["Rental"]] = None,
        user_id: Optional[str] = None,
    ) -> None:
        """Constructor method for BaseUser class."""
        # Call parent class constructor
        super().__init__(
            first_name=first_name,
            last_name=last_name,
            gender=gender,
            birth_date=birth_date,
            email=email,
            address=address,
            phone_number=phone_number,
            user_id=user_id,
        )

        # Validate reservation
        if reservations is None:
            reservations = []
        else:
            # Validate employee is a list
            if not isinstance(reservations, list):
                raise ValueError("reservations must be a list.")
            # Validate all items in the list are Employee instances
            from domain.reservation import Reservation  # To avoid circular import

            if not all(
                isinstance(reservation, Reservation) for reservation in reservations
            ):
                raise ValueError(
                    "all reservations must be instances of Reservation class"
                )

        # Validate rentals
        if rentals is None:
            rentals = []
        else:
            if not isinstance(rentals, list):
                raise ValueError("rentals must be a list.")
            from domain.rental import Rental

            if not all(isinstance(rental, Rental) for rental in rentals):
                raise ValueError("all rentals must be instances of Rental class")

        # Assign reservations
        self.__reservations = reservations
        self.__rentals = rentals

    @property
    def reservations(self) -> List["Reservation"]:
        """Getter method for reservations."""
        return self.__reservations

    @property
    def rentals(self) -> List["Rental"]:
        """Getter method for rentals."""
        return self.__rentals

    def get_reservations(self) -> List["Reservation"]:
        """Returns all reservations created by the customer"""
        return self.__reservations

    def create_reservation(
        self,
        vehicle: "Vehicle",
        insurance_tier: "InsuranceTier",
        pickup_branch: "Branch",
        return_branch: "Branch",
        pickup_date: date,
        return_date: date,
        add_ons: Optional[List["AddOn"]] = None,
        clock: Optional["ClockService"] = None,
    ) -> "Reservation":
        """
        Creates a new reservation and adds it to the customer's reservations.

        Args:
            vehicle (Vehicle): The vehicle to reserve.
            insurance_tier (InsuranceTier): The insurance tier for the reservation.
            pickup_branch (Branch): The branch where the vehicle will be picked up.
            return_branch (Branch): The branch where the vehicle will be returned.
            pickup_date (date): The date when the vehicle will be picked up.
            return_date (date): The date when the vehicle will be returned.
            add_ons (Optional[List[AddOn]]): Optional list of add-ons. Defaults to None.
            clock (Optional[ClockService]): Optional clock service for time-based calculations.

        Returns:
            Reservation: The newly created reservation.

        Raises:
            TypeError: If any parameter has an incorrect type.
            ValueError: If dates violate business constraints.
        """
        from core.clock_service import SystemClock
        from domain.reservation import Reservation

        if vehicle.status != VehicleStatus.AVAILABLE.value:
            raise VehicleNotAvailableError("This car is already reserved.")

        clock = clock or SystemClock()

        # Change vehicle status to RESERVED
        vehicle.reserve()

        # Create new reservation with PENDING status
        new_reservation = Reservation(
            status=ReservationStatus.PENDING,
            creator=self,
            vehicle=vehicle,
            insurance_tier=insurance_tier,
            pickup_branch=pickup_branch,
            return_branch=return_branch,
            pickup_date=pickup_date,
            return_date=return_date,
            add_ons=add_ons,
            clock=clock,
        )

        # Add to customer's reservations
        self.__reservations.append(new_reservation)

        return new_reservation

    def cancel_reservation(self, reservation_id: str) -> None:
        """
        Cancel a reservation if it belongs to the customer.

        Changes the reservation status to CANCELLED. Only reservations with
        PENDING or CONFIRMED status can be canceled.

        Args:
            reservation_id (str): The unique ID of the reservation to cancel.

        Raises:
            TypeError: If reservation_id is not a string.
            ValueError: If reservation_id is empty, reservation is not found,
                or reservation cannot be canceled (already active, completed, or canceled).
        """
        # Validate reservation_id
        if not isinstance(reservation_id, str):
            raise TypeError("reservation_id must be a string.")
        if not reservation_id:
            raise ValueError("reservation_id cannot be empty.")

        # Find the reservation
        reservation = None
        for res in self.__reservations:
            if res.id == reservation_id:
                reservation = res
                break

        # Check if reservation exists
        if reservation is None:
            raise ValueError("Reservation with the given ID is not found.")

        # Check if reservation can be canceled
        if reservation.status == ReservationStatus.CANCELLED.value:
            raise InvalidReservationStatusForCancellationError(reservation.status)
        if reservation.status == ReservationStatus.COMPLETED.value:
            raise InvalidReservationStatusForCancellationError(reservation.status)
        if reservation.status == ReservationStatus.PICKED_UP.value:
            raise InvalidReservationStatusForCancellationError(reservation.status)

        # Cancel the reservation
        reservation.status = ReservationStatus.CANCELLED
        # Change vehicle status to AVAILABLE
        reservation.vehicle.status = VehicleStatus.AVAILABLE

    def pickup_vehicle(
        self,
        reservation_id: str,
        pickup_token: str,
        odometer: float,
        fuel_level: float,
        clock: Optional["ClockService"] = None,
    ) -> "Rental":
        """
        Pick up a vehicle and create an active rental.

        Creates a Rental entity with odometer/fuel readings at pickup.
        The pickup_token ensures idempotent pickups (prevents duplicates).

        Args:
            reservation_id (str): The unique ID of the reservation.
            pickup_token (str): Unique token for idempotent pickup.
            odometer (float): Current odometer reading.
            fuel_level (float): Current fuel level (0.0 to 1.0).
            clock (Optional[ClockService]): Clock service for timestamp.

        Returns:
            Rental: The newly created rental.

        Raises:
            TypeError: If parameters have incorrect types.
            ValueError: If reservation not found, not approved, or already picked up.
            PaymentRequiredForPickupError: If invoice not paid.
        """
        from core.clock_service import SystemClock
        from domain.rental import Rental
        from schemas.entities import RentalReading

        clock = clock or SystemClock()

        # Validate parameters
        if not isinstance(reservation_id, str):
            raise TypeError("reservation_id must be a string.")
        if not reservation_id:
            raise ValueError("reservation_id cannot be empty.")

        if not isinstance(pickup_token, str):
            raise TypeError("pickup_token must be a string.")
        if not pickup_token:
            raise ValueError("pickup_token cannot be empty.")

        if not isinstance(odometer, (int, float)):
            raise TypeError("odometer must be a numeric value.")
        if odometer < 0:
            raise ValueError("odometer cannot be negative.")

        if not isinstance(fuel_level, (int, float)):
            raise TypeError("fuel_level must be a numeric value.")
        if not (0 <= fuel_level <= 1):
            raise ValueError("fuel_level must be between 0 and 1.")

        # Check for duplicate pickup (idempotency)
        for existing_rental in self.__rentals:
            if existing_rental.pickup_token == pickup_token:
                return existing_rental  # Return existing rental, don't create duplicate

        # Find the reservation
        reservation = None
        for res in self.__reservations:
            if res.id == reservation_id:
                reservation = res
                break

        if reservation is None:
            raise ReservationNotFoundError(reservation_id)

        # Check if reservation is approved
        if reservation.status != ReservationStatus.APPROVED.value:
            raise ReservationNotApprovedError(reservation_id)

        # Check if invoice is paid
        if reservation.invoice.status != InvoiceStatus.COMPLETED.value:
            raise PaymentRequiredForPickupError(reservation_id)

        # Create pickup readings
        pickup_readings = RentalReading(
            odometer=odometer,
            fuel_level=fuel_level,
            timestamp=clock.now(),
        )

        # Create rental
        rental = Rental(
            reservation=reservation,
            pickup_token=pickup_token,
            pickup_readings=pickup_readings,
            clock=clock,
        )

        # Update statuses
        reservation.status = ReservationStatus.PICKED_UP
        reservation.vehicle.status = VehicleStatus.PICKED_UP

        # Store rental
        self.__rentals.append(rental)

        return rental

    def return_vehicle(
        self,
        reservation_id: str,
        odometer: float,
        fuel_level: float,
        manual_damage_charge: float = 0.0,
        clock: Optional["ClockService"] = None,
    ) -> "RentalCharges":
        """
        Return a vehicle and calculate all charges.

        Completes the rental by recording return readings and computing:
        - Grace period (1 hour free)
        - Late fees ($10/hour after grace)
        - Mileage overage (200km/day allowance, $0.50/km over)
        - Fuel refill charges
        - Manual damage charges

        Args:
            reservation_id (str): The unique ID of the reservation.
            odometer (float): Odometer reading at return.
            fuel_level (float): Fuel level at return (0.0 to 1.0).
            manual_damage_charge (float): Optional damage fee assessed by agent.
            clock (Optional[ClockService]): Clock service for timestamp.

        Returns:
            RentalCharges: Itemized breakdown of all charges.

        Raises:
            TypeError: If parameters have incorrect types.
            ValueError: If reservation not found, not picked up, or already returned.
        """
        from core.clock_service import SystemClock
        from schemas.entities import RentalReading

        clock = clock or SystemClock()

        # Validate parameters
        if not isinstance(reservation_id, str):
            raise TypeError("reservation_id must be a string.")
        if not reservation_id:
            raise ValueError("reservation_id cannot be empty.")

        if not isinstance(odometer, (int, float)):
            raise TypeError("odometer must be a numeric value.")
        if odometer < 0:
            raise ValueError("odometer cannot be negative.")

        if not isinstance(fuel_level, (int, float)):
            raise TypeError("fuel_level must be a numeric value.")
        if not (0 <= fuel_level <= 1):
            raise ValueError("fuel_level must be between 0 and 1.")

        if not isinstance(manual_damage_charge, (int, float)):
            raise TypeError("manual_damage_charge must be a numeric value.")
        if manual_damage_charge < 0:
            raise ValueError("manual_damage_charge cannot be negative.")

        # Find the reservation
        reservation = None
        for res in self.__reservations:
            if res.id == reservation_id:
                reservation = res
                break

        if reservation is None:
            raise ValueError("Reservation with the given ID is not found.")

        # Check if vehicle is picked up
        if reservation.status != ReservationStatus.PICKED_UP.value:
            raise ValueError("Only picked-up reservations can be returned.")

        # Find the active rental
        rental = None
        for r in self.__rentals:
            if r.reservation.id == reservation_id and not r.is_returned():
                rental = r
                break

        if rental is None:
            raise ValueError("No active rental found for this reservation.")

        # Create return readings
        return_readings = RentalReading(
            odometer=odometer,
            fuel_level=fuel_level,
            timestamp=clock.now(),
        )

        # Complete return and calculate charges
        charges = rental.complete_return(
            return_readings=return_readings,
            manual_damage_charge=manual_damage_charge,
        )

        # Update statuses
        reservation.status = ReservationStatus.COMPLETED
        reservation.vehicle.status = VehicleStatus.AVAILABLE

        return charges

    @staticmethod
    def make_creditcard_payment(
        reservation: "Reservation", card_number: str, cvv: str, expiry: str
    ):
        """
        Make payment for a reservation with creditcard.

        Args:
            reservation (Reservation): Reservation object.
            card_number (str): Credit card number.
            cvv (str): Card CVV code.
            expiry (str): Card expiry date.

        Raises:
            TypeError: If reservation is not a Reservation object.
            ValueError: If reservation status is not APPROVED.
        """
        # Validation
        from domain.reservation import Reservation

        if not isinstance(reservation, Reservation):
            raise TypeError("reservation must be a Reservation object.")

        if reservation.status != ReservationStatus.APPROVED.value:
            raise ReservationNotApprovedError(reservation.id)

        # Create payment
        from domain.payment import CreditCardPaymentCreator

        credit_card_payment_service = CreditCardPaymentCreator(
            card_number=card_number, cvv=cvv, expiry=expiry
        )

        # Execute payment
        receipt = credit_card_payment_service.execute_payment(reservation.total_price)

        # Change invoice status
        if "successful" in receipt:
            reservation.invoice.payment_completed()

        else:
            reservation.invoice.payment_failed()

        return receipt

    @staticmethod
    def make_paypal_payment(reservation: "Reservation", email: str, auth_token: str):
        """
        Make payment for a reservation with creditcard.

        Args:
            reservation (Reservation): Reservation object.
            email (str): PayPal account email.
            auth_token (str): PayPal authentication token.

        Raises:
            TypeError: If reservation is not a Reservation object.
            ValueError: If reservation status is not APPROVED.
        """
        # Validation
        from domain.reservation import Reservation

        if not isinstance(reservation, Reservation):
            raise TypeError("reservation must be a Reservation object.")

        if reservation.status != ReservationStatus.APPROVED.value:
            raise ValueError("Only approved reservations can be paid.")

        # Create payment
        from domain.payment import PaypalPaymentCreator

        credit_card_payment_service = PaypalPaymentCreator(
            email=email, auth_token=auth_token
        )

        # Execute payment
        receipt = credit_card_payment_service.execute_payment(reservation.total_price)

        # Change invoice status
        if "successful" in receipt:
            reservation.invoice.payment_completed()

        else:
            reservation.invoice.payment_failed()

        return receipt

    def get_role(self) -> str:
        """Returns role of the user in the application"""
        return "customer"

    def get_information(self) -> dict[str, Any]:
        """Returns a dictionary including all user information"""
        return {
            "first_name": self.first_name,
            "last_name": self.last_name,
            "gender": self.gender,
            "birth_date": self.birth_date,
            "email": self.email,
            "phone_number": self.phone_number,
            "address": self.address,
            "reservations": self.__reservations,
            "rentals": self.__rentals,
        }

    def __str__(self):
        """Returns a string representation of the customer"""
        return f"Customer(Name: {self.first_name.title()} {self.last_name.title()}, Gender: {self.gender.title()}, Role: {self.get_role().title()})"
