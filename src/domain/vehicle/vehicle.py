"""
This module implements Vehicle class.
It is a concrete class and can directly initialize in the app.

Business Logics:
    - id is autogenerated and cannot be changes.
    - Vehicle price cannot be lower than its VehicleClass base_price.

Author: Peyman Khodabandehlouei
Date: 07-11-2025
"""

import uuid
from typing import List, Optional, TYPE_CHECKING
from schemas.domain import VehicleStatus


if TYPE_CHECKING:
    from core import ClockService
    from domain.branch import Branch
    from domain.vehicle import VehicleClass, MaintenanceRecord


class Vehicle:
    """
    Concrete class representing a Vehicle in the application.

    Args:
        vehicle_class (VehicleClass): VehicleClass of the vehicle.
        current_branch (Branch): Current branch of the vehicle.
        status (VehicleStatus): Current status of the vehicle.
        brand (str): Brand of the vehicle.
        model (str): Model of the vehicle.
        color (str): Color of the vehicle.
        licence_plate (str): Licence plate of the vehicle.
        fuel_level (float): Fuel level of the vehicle.
        last_service_odometer (float): Last service odometer of the vehicle.
        odometer (float): Current odometer of the vehicle.
        price_per_day (float): Price of the vehicle per day.
        maintenance_records (Optional[List[MaintenanceRecord]]): List of maintenance records.
        vehicle_id (Optional[str]): ID of the vehicle.

    Raises:
        TypeError: If any parameter has an incorrect type (vehicle_class must be VehicleClass,
            current_branch must be Branch, status must be VehicleStatus enum, brand/model/color/
            licence_plate must be strings, fuel_level/last_service_odometer/odometer/price_per_day
            must be numeric, maintenance_records must be a list of MaintenanceRecord instances).
        ValueError: If fuel_level is negative, last_service_odometer is negative, odometer is less
            than last_service_odometer, or price_per_day is less than vehicle_class.base_daily_rate.
    """

    def __init__(
        self,
        vehicle_class: "VehicleClass",
        current_branch: "Branch",
        status: VehicleStatus,
        brand: str,
        model: str,
        color: str,
        licence_plate: str,
        fuel_level: float,
        last_service_odometer: float,
        odometer: float,
        price_per_day: float,
        maintenance_records: Optional[List["MaintenanceRecord"]] = None,
        vehicle_id: Optional[str] = None,
    ):
        """Constructor method for Vehicle class"""
        # Validate vehicle_class
        from domain.vehicle import VehicleClass  # To avoid circular import

        if not isinstance(vehicle_class, VehicleClass):
            raise TypeError("vehicle_class must be a VehicleClass object")

        # Validate branch
        from domain.branch import Branch  # To avoid circular import

        if not isinstance(current_branch, Branch):
            raise TypeError("current_branch must be a Branch object")

        # Validate status
        if not isinstance(status, VehicleStatus):
            raise TypeError("Vehicle status must be a VehicleStatus enum")

        # Validate brand
        if not isinstance(brand, str):
            raise TypeError("brand must be a string")

        # Validate model
        if not isinstance(model, str):
            raise TypeError("model must be a string")

        # Validate color
        if not isinstance(color, str):
            raise TypeError("color must be a string")

        # Validate licence_plate
        if not isinstance(licence_plate, str):
            raise TypeError("licence_plate must be a string")

        # Validate fuel_level
        if not isinstance(fuel_level, (int, float)):
            raise TypeError("fuel_level must be a numeric value")
        if fuel_level < 0:
            raise ValueError("fuel_level cannot be negative")

        # Validate last_service_odometer
        if not isinstance(last_service_odometer, (int, float)):
            raise TypeError("last_service_odometer must be a numeric value")
        if last_service_odometer < 0:
            raise ValueError("last_service_odometer cannot be negative")

        # Validate odometer
        if not isinstance(odometer, (int, float)):
            raise TypeError("odometer must be a numeric value")
        if odometer < last_service_odometer:
            raise ValueError("odometer cannot be less than last_service_odometer")

        # Validate price_per_day
        if not isinstance(price_per_day, (int, float)):
            raise TypeError("price_per_day must be a numeric value")
        if price_per_day < vehicle_class.base_daily_rate:
            raise ValueError(
                "price_per_day can not be less than vehicle_class.base_daily_rate"
            )

        # Validate maintenance_records
        if maintenance_records is None:
            maintenance_records = []

        # Validate maintenance_records is a list
        if not isinstance(maintenance_records, list):
            raise TypeError("maintenance_records must be a list")

        # Validate all items in the list are MaintenanceRecord instances
        from domain.vehicle import MaintenanceRecord  # To avoid circular import

        if not all(
            isinstance(maintenance_record, MaintenanceRecord)
            for maintenance_record in maintenance_records
        ):
            raise TypeError(
                "All maintenance records must be an instances of MaintenanceRecord class"
            )

        # Validate id
        if vehicle_id is not None and not isinstance(vehicle_id, str):
            raise TypeError("vehicle_id must be a string.")
        if vehicle_id == "":
            raise ValueError("vehicle_id cannot be empty.")

        # Assign Values
        self.__id = vehicle_id if vehicle_id is not None else str(uuid.uuid4())
        self.__vehicle_class = vehicle_class
        self.__current_branch = current_branch
        self.__status = status
        self.__brand = brand
        self.__model = model
        self.__color = color
        self.__licence_plate = licence_plate
        self.__fuel_level = fuel_level
        self.__odometer = odometer
        self.__last_service_odometer = last_service_odometer
        self.__price_per_day = price_per_day
        self.__maintenance_records = maintenance_records.copy()

    @property
    def id(self) -> str:
        """
        Getter method for id property.

        Note: ID is auto-generated and immutable. Cannot be modified after creation.
        """
        return self.__id

    @property
    def vehicle_class(self) -> "VehicleClass":
        """Getter for vehicle_class property"""
        return self.__vehicle_class

    @vehicle_class.setter
    def vehicle_class(self, vehicle_class: "VehicleClass") -> None:
        """
        Setter for vehicle_class property

        Args:
            vehicle_class (VehicleClass): VehicleClass of the vehicle.

        Raises:
            TypeError: If vehicle_class is not an instance of VehicleClass.
        """
        # Validation
        from domain.vehicle import VehicleClass

        if not isinstance(vehicle_class, VehicleClass):
            raise TypeError("vehicle_class must be a VehicleClass object")

        # Logic
        self.__vehicle_class = vehicle_class

    @property
    def current_branch(self) -> "Branch":
        """Getter for branch property"""
        return self.__current_branch

    @current_branch.setter
    def current_branch(self, branch: "Branch") -> None:
        """
        Setter for branch property

        Args:
            branch (Branch): Current branch of the vehicle.

        Raises:
            TypeError: If branch is not an instance of Branch.
        """
        # Validation
        from domain.branch import Branch

        if not isinstance(branch, Branch):
            raise TypeError("branch must be a Branch object")

        # Logic
        self.__current_branch = branch

    @property
    def status(self) -> str:
        """Getter for status property"""
        return self.__status.value

    @status.setter
    def status(self, status: VehicleStatus) -> None:
        """
        Setter for status property

        Args:
            status (VehicleStatus): VehicleStatus of the vehicle.

        Raises:
            TypeError: If status is not an instance of VehicleStatus.
        """
        if not isinstance(status, VehicleStatus):
            raise TypeError("status must be a VehicleStatus enum")

        self.__status = status

    @property
    def brand(self) -> str:
        """Getter for Brand property"""
        return self.__brand

    @brand.setter
    def brand(self, brand: str) -> None:
        """
        Setter for Brand property

        Args:
            brand (str): Brand name of the vehicle.

        Raises:
            TypeError: If brand is not string.
        """
        # Validation
        if not isinstance(brand, str):
            raise TypeError("brand must be a string")

        # Logic
        self.__brand = brand

    @property
    def model(self) -> str:
        """Getter for model property"""
        return self.__model

    @model.setter
    def model(self, model: str) -> None:
        """
        Setter for model property

        Args:
            model (str): Model of the vehicle.

        Raises:
            TypeError: If model is not string.
        """
        # Validation
        if not isinstance(model, str):
            raise TypeError("model must be a string")

        # Logic
        self.__model = model

    @property
    def color(self) -> str:
        """Getter for color property"""
        return self.__color

    @color.setter
    def color(self, color: str) -> None:
        """
        Setter for color property

        Args:
            color (str): color of the vehicle.

        Raises:
            TypeError: If color is not string.
        """
        # Validation
        if not isinstance(color, str):
            raise TypeError("color must be a string")

        # Logic
        self.__color = color

    @property
    def licence_plate(self) -> str:
        """Getter for licence plate property"""
        return self.__licence_plate

    @licence_plate.setter
    def licence_plate(self, licence_plate: str) -> None:
        """
        Setter for licence plate property

        Args:
            licence_plate (str): licence plate of the vehicle.

        Raises:
            TypeError: If licence_plate is not string.
        """
        # Validation
        if not isinstance(licence_plate, str):
            raise TypeError("licence_plate must be a string")

        # Logic
        self.__licence_plate = licence_plate

    @property
    def fuel_level(self) -> float:
        """Getter for fuel_level property"""
        return self.__fuel_level

    @fuel_level.setter
    def fuel_level(self, fuel_level: float) -> None:
        """
        Setter for fuel_level property

        Args:
            fuel_level (float): fuel level of the vehicle.

        Raises:
            TypeError: If fuel_level is not a numeric value.
            ValueError: If fuel_level is less than 0.
        """
        # Validation
        if not isinstance(fuel_level, (int, float)):
            raise TypeError("fuel_level must be a numeric value")
        if fuel_level < 0:
            raise ValueError("fuel_level cannot be negative")

        # Logic
        self.__fuel_level = fuel_level

    @property
    def odometer(self) -> float:
        """Getter for odometer property"""
        return self.__odometer

    @odometer.setter
    def odometer(self, odometer: float) -> None:
        """
        Setter for odometer property

        Args:
            odometer (float): odometer value of the vehicle.

        Raises:
            TypeError: If odometer is not a numeric value.
            ValueError: If odometer is less than last_service_odometer.
        """
        # Validation
        if not isinstance(odometer, (int, float)):
            raise TypeError("odometer must be a numeric value")
        if odometer < self.__last_service_odometer:
            raise ValueError("odometer cannot be less than last_service_odometer")

        # Logic
        self.__odometer = odometer

    @property
    def last_service_odometer(self) -> float:
        """Getter for last_service_odometer property"""
        return self.__last_service_odometer

    @last_service_odometer.setter
    def last_service_odometer(self, last_service_odometer: float) -> None:
        """
        Setter for last_service_odometer property

        Args:
            last_service_odometer (float): last_service_odometer value of the vehicle.

        Raises:
            TypeError: If last_service_odometer is not a numeric value.
            ValueError: If last_service_odometer is less than 0.
        """
        if not isinstance(last_service_odometer, (int, float)):
            raise TypeError("last_service_odometer must be a numeric value.")
        if last_service_odometer < 0:
            raise ValueError("last_service_odometer cannot be negative.")

        self.__last_service_odometer = last_service_odometer

    @property
    def price_per_day(self) -> float:
        """Getter for price_per_day property"""
        return self.__price_per_day

    @price_per_day.setter
    def price_per_day(self, price_per_day: float) -> None:
        """
        Setter for price_per_day property

        Args:
            price_per_day (float): price_per_day value of the vehicle.

        Raises:
            TypeError: If price_per_day is not a numeric value.
            ValueError: If price_per_day is less than vehicle_class.base_daily_rate.
        """
        if not isinstance(price_per_day, (int, float)):
            raise TypeError("price_per_day must be a numeric value.")
        if price_per_day < self.vehicle_class.base_daily_rate:
            raise ValueError(
                "price_per_day can not be less than vehicle_class.base_daily_rate"
            )

        self.__price_per_day = price_per_day

    @property
    def maintenance_records(self) -> List["MaintenanceRecord"]:
        """Getter for maintenance_records property"""
        return self.__maintenance_records.copy()

    @maintenance_records.setter
    def maintenance_records(
        self, maintenance_records: List["MaintenanceRecord"]
    ) -> None:
        """
        Setter for maintenance_records property

        Args:
            maintenance_records (List[MaintenanceRecord]): list of maintenance records.

        Raises:
            TypeError: If maintenance_records is not a list.
            ValueError: If all items in the maintenance_records list are not MaintenanceRecord objects.
        """
        from domain.vehicle import MaintenanceRecord

        if not isinstance(maintenance_records, list):
            raise TypeError("maintenance_records must be a list")
        if not all(
            isinstance(maintenance_record, MaintenanceRecord)
            for maintenance_record in maintenance_records
        ):
            raise TypeError(
                "All maintenance records must be an instances of MaintenanceRecord class"
            )

        self.__maintenance_records = maintenance_records.copy()

    def reserve(self) -> None:
        """Updates the status of the Vehicle to RESERVED"""
        self.status = VehicleStatus.RESERVED

    def make_available(self) -> None:
        """Updates the status of the Vehicle to AVAILABLE"""
        self.status = VehicleStatus.AVAILABLE

    def move_to_maintenance(self) -> None:
        """Updates the status of the Vehicle to OUT_OF_SERVICE"""
        self.status = VehicleStatus.OUT_OF_SERVICE

    def add_maintenance_record(self, maintenance_record: "MaintenanceRecord") -> None:
        """Adds a new maintenance record to the vehicle's maintenance_records list"""
        # Validation
        from domain.vehicle import MaintenanceRecord

        if not isinstance(maintenance_record, MaintenanceRecord):
            raise TypeError(
                "maintenance_record must be an instance of MaintenanceRecord class"
            )
        if maintenance_record in self.maintenance_records:
            raise ValueError("maintenance_record already exists in the list")

        self.__maintenance_records.append(maintenance_record)

    def is_maintenance_due(
        self,
        threshold_km: float = 10000,
        threshold_days: int = 180,
        clock: Optional["ClockService"] = None,
    ) -> bool:
        """
        Check if vehicle needs maintenance based on odometer or time thresholds.

        Vehicle is considered maintenance-due if:
            - Within 500km of the odometer threshold, OR
            - Past the time threshold since last service

        Args:
            threshold_km (float): Service interval in kilometers. Defaults to 10,000 km.
            threshold_days (int): Service interval in days. Defaults to 180 days.
            clock (Optional[ClockService]): Clock service for time checks. Uses SystemClock if None.

        Returns:
            bool: True if maintenance is due, False otherwise.

        Raises:
            TypeError: If threshold_km or threshold_days are not numeric.
            ValueError: If threshold_km or threshold_days are negative.
        """
        # Validation
        if not isinstance(threshold_km, (int, float)):
            raise TypeError("threshold_km must be a numeric value")
        if threshold_km < 0:
            raise ValueError("threshold_km cannot be negative")

        if not isinstance(threshold_days, int):
            raise TypeError("threshold_days must be an integer")
        if threshold_days < 0:
            raise ValueError("threshold_days cannot be negative")

        # Use SystemClock if no clock provided
        from core.clock_service import SystemClock

        clock = clock or SystemClock()

        # Check odometer threshold (within 500km)
        km_since_last_service = self.__odometer - self.__last_service_odometer
        km_until_service = threshold_km - km_since_last_service

        if km_until_service <= 500:
            return True

        # Check time threshold
        if self.__maintenance_records:
            last_service_date = self.__maintenance_records[-1].service_date
            days_since_service = (clock.today() - last_service_date).days

            if days_since_service >= threshold_days:
                return True

        return False

    def __str__(self):
        """String representation of the Vehicle"""
        return f"Vehicle(id={self.id}, vehicle_class={self.vehicle_class.name}, brand={self.brand}, model={self.model}, color={self.color}, licence_plate={self.licence_plate}, fuel_level={self.fuel_level}, last_service_odometer={self.last_service_odometer}, odometer={self.odometer}, price_per_day={self.price_per_day}, status={self.status.title()})"
