"""
This module implements Invoice class
It is a concrete class and can directly initialize in the app.

Business Logic:
    - id and date are autogenerated and cannot be edited.
    - All Invoice attributes expect status are immutable and cannot be changed after initialization.

Author: Peyman Khodabandehlouei
Date: 07-11-2025
"""

import uuid
from datetime import date
from schemas.entities import InvoiceStatus
from typing import TYPE_CHECKING, Optional


if TYPE_CHECKING:
    from entities.user import Customer
    from entities.reservation import Reservation


class Invoice:
    """
    Concrete class representing an invoice in the application.
    This class can be directly initialized and used during application runtime.

    Args:
        creator (Customer): Customer creating the invoice.
        reservation (Reservation): Reservation associated with the invoice.
        invoice_id (optional[str]): ID of the invoice.

    Raises:
        TypeError: If any parameter has an incorrect type (tier_name/description must be strings, price_per_day must be numeric).
        ValueError: If price_per_day is negative.
    """

    def __init__(
        self,
        creator: "Customer",
        reservation: "Reservation",
        invoice_id: Optional[str] = None,
        total_price: Optional[float] = None,
        invoice_date: Optional[date] = None,
        status: Optional[InvoiceStatus] = None,
    ) -> None:
        # Validation
        from entities.user import Customer

        if not isinstance(creator, Customer):
            raise TypeError("creator must be a Customer object")
        from entities.reservation import Reservation

        if not isinstance(reservation, Reservation):
            raise TypeError("reservation must be a Reservation object")

        # Validate id
        if invoice_id is not None and not isinstance(invoice_id, str):
            raise TypeError("invoice_id must be a string.")
        if invoice_id == "":
            raise ValueError("invoice_id cannot be empty.")

        self.__id = invoice_id if invoice_id is not None else str(uuid.uuid4())
        self.__creator = creator
        self.__reservation = reservation
        self.__total_price = (
            total_price if total_price is not None else reservation.total_price
        )
        self.__date = invoice_date if invoice_date is not None else date.today()
        self.__status = status if status is not None else InvoiceStatus.PENDING

    @property
    def id(self) -> str:
        """Getter for id property."""
        return self.__id

    @property
    def creator(self) -> "Customer":
        """Getter for creator property."""
        return self.__creator

    @property
    def reservation(self) -> "Reservation":
        """Getter for reservation property."""
        return self.__reservation

    @property
    def total_price(self) -> float:
        """Getter for total_price property."""
        return self.__total_price

    @property
    def date(self) -> date:
        """Getter for date property."""
        return self.__date

    @property
    def status(self) -> InvoiceStatus:
        """Getter for status property."""
        return self.__status.value

    def payment_completed(self):
        """Updates invoice status to COMPLETED"""
        self.__status = InvoiceStatus.COMPLETED

    def payment_failed(self):
        """Updates invoice status to FAILED"""
        self.__status = InvoiceStatus.FAILED

    def __str__(self):
        """String representation of the Invoice object"""
        return f"Invoice(id={self.__id}, creator={self.__creator.id}, reservation={self.__reservation.id}, total_price={self.__total_price}, date={self.__date}, status={self.__status})"
