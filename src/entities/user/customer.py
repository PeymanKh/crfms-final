"""
This module implements Customer class.
It is a concrete class and can directly initialize in the app.

Business Logic:
    - id is autogenerated and cannot be edited.
    - Customer can pay only for approved reservations.

Author: Peyman Khodabandehlouei
Date: 30-10-2025
"""

from datetime import date
from typing import Any, Optional, List, TYPE_CHECKING

from entities.user import BaseUser
from schemas.entities import Gender, ReservationStatus, VehicleStatus, InvoiceStatus
from core import (
    VehicleNotAvailableError,
    ReservationNotFoundError,
    InvalidReservationStatusForCancellationError,
    PaymentRequiredForPickupError,
    ReservationNotApprovedError,
)

if TYPE_CHECKING:
    from entities.branch import Branch
    from entities.vehicle import Vehicle
    from entities.reservation import AddOn, Reservation, InsuranceTier


class Customer(BaseUser):
    """
    Concrete class representing a customer in the application.

    Args:
        first_name (str): First name of the employee.
        last_name (str): Last name of the employee.
        gender (Gender): Gender of the employee (Gender enum).
        birth_date (date): Birth date of the employee (must be >= 18 years ago).
        email (EmailStr): Email address of the employee.
        address (str): Home address of the employee.
        phone_number (str): Phone number of the employee.
        reservations (Reservation): Reservations made by the customer.
        user_id (Optional[str]): ID of the customer.
    """

    def __init__(
        self,
        first_name: str,
        last_name: str,
        gender: Gender,
        birth_date: date,
        email: str,
        address: str,
        phone_number: str,
        reservations: Optional[List["Reservation"]] = None,
        user_id: Optional[str] = None,
    ) -> None:
        """Constructor method for BaseUser class."""
        # Call parent class constructor
        super().__init__(
            first_name=first_name,
            last_name=last_name,
            gender=gender,
            birth_date=birth_date,
            email=email,
            address=address,
            phone_number=phone_number,
            user_id=user_id,
        )

        # Validate reservation
        if reservations is None:
            reservations = []
        else:
            # Validate employee is a list
            if not isinstance(reservations, list):
                raise ValueError("reservations must be a list.")
            # Validate all items in the list are Employee instances
            from entities.reservation import Reservation  # To avoid circular import

            if not all(
                isinstance(reservation, Reservation) for reservation in reservations
            ):
                raise ValueError(
                    "all reservations must be instances of Reservation class"
                )

        # Assign reservations
        self.__reservations = reservations

    @property
    def reservations(self) -> List["Reservation"]:
        """Getter method for reservations."""
        return self.__reservations

    def get_reservations(self) -> List["Reservation"]:
        """Returns all reservations created by the customer"""
        return self.__reservations

    def create_reservation(
        self,
        vehicle: "Vehicle",
        insurance_tier: "InsuranceTier",
        pickup_branch: "Branch",
        return_branch: "Branch",
        pickup_date: date,
        return_date: date,
        add_ons: Optional[List["AddOn"]] = None,
    ) -> "Reservation":
        """
        Creates a new reservation and adds it to the customer's reservations.

        Args:
            vehicle (Vehicle): The vehicle to reserve.
            insurance_tier (InsuranceTier): The insurance tier for the reservation.
            pickup_branch (Branch): The branch where the vehicle will be picked up.
            return_branch (Branch): The branch where the vehicle will be returned.
            pickup_date (date): The date when the vehicle will be picked up.
            return_date (date): The date when the vehicle will be returned.
            add_ons (Optional[List[AddOn]]): Optional list of add-ons. Defaults to None.

        Returns:
            Reservation: The newly created reservation.

        Raises:
            TypeError: If any parameter has an incorrect type.
            ValueError: If dates violate business constraints.
        """
        from entities.reservation import Reservation

        if vehicle.status != VehicleStatus.AVAILABLE.value:
            raise VehicleNotAvailableError("This car is already reserved.")

        # Change vehicle status to RESERVED
        vehicle.reserve()

        # Create new reservation with PENDING status
        new_reservation = Reservation(
            status=ReservationStatus.PENDING,
            creator=self,
            vehicle=vehicle,
            insurance_tier=insurance_tier,
            pickup_branch=pickup_branch,
            return_branch=return_branch,
            pickup_date=pickup_date,
            return_date=return_date,
            add_ons=add_ons,
        )

        # Add to customer's reservations
        self.__reservations.append(new_reservation)

        return new_reservation

    def cancel_reservation(self, reservation_id: str) -> None:
        """
        Cancel a reservation if it belongs to the customer.

        Changes the reservation status to CANCELLED. Only reservations with
        PENDING or CONFIRMED status can be canceled.

        Args:
            reservation_id (str): The unique ID of the reservation to cancel.

        Raises:
            TypeError: If reservation_id is not a string.
            ValueError: If reservation_id is empty, reservation is not found,
                or reservation cannot be canceled (already active, completed, or canceled).
        """
        # Validate reservation_id
        if not isinstance(reservation_id, str):
            raise TypeError("reservation_id must be a string.")
        if not reservation_id:
            raise ValueError("reservation_id cannot be empty.")

        # Find the reservation
        reservation = None
        for res in self.__reservations:
            if res.id == reservation_id:
                reservation = res
                break

        # Check if reservation exists
        if reservation is None:
            raise ValueError("Reservation with the given ID is not found.")

        # Check if reservation can be canceled
        if reservation.status == ReservationStatus.CANCELLED.value:
            raise InvalidReservationStatusForCancellationError(reservation.status)
        if reservation.status == ReservationStatus.COMPLETED.value:
            raise InvalidReservationStatusForCancellationError(reservation.status)
        if reservation.status == ReservationStatus.PICKED_UP.value:
            raise InvalidReservationStatusForCancellationError(reservation.status)

        # Cancel the reservation
        reservation.status = ReservationStatus.CANCELLED
        # Change vehicle status to AVAILABLE
        reservation.vehicle.status = VehicleStatus.AVAILABLE

    def pickup_vehicle(self, reservation_id: str) -> None:
        """
        Mark a vehicle as picked up for a confirmed reservation.

        Changes the reservation status to ACTIVE and the vehicle status to PICKED_UP.
        Only reservations with CONFIRMED status can be picked up.

        Args:
            reservation_id (str): The unique ID of the reservation.

        Raises:
            TypeError: If reservation_id is not a string.
            ValueError: If reservation_id is empty, reservation is not found,
                or reservation status is not CONFIRMED.
        """
        from schemas.entities import ReservationStatus, VehicleStatus

        # Validate reservation_id
        if not isinstance(reservation_id, str):
            raise TypeError("reservation_id must be a string.")
        if not reservation_id:
            raise ValueError("reservation_id cannot be empty.")

        # Find the reservation
        reservation = None
        for res in self.__reservations:
            if res.id == reservation_id:
                reservation = res
                break

        # Check if reservation exists
        if reservation is None:
            raise ReservationNotFoundError(reservation_id)

        # Check if reservation can be picked up
        if reservation.status != ReservationStatus.APPROVED.value:
            raise ReservationNotApprovedError(reservation_id)

        if reservation.invoice.status != InvoiceStatus.COMPLETED.value:
            raise PaymentRequiredForPickupError(reservation_id)

        # Update reservation status to ACTIVE
        reservation.status = ReservationStatus.PICKED_UP

        # Update vehicle status to PICKED_UP
        reservation.vehicle.status = VehicleStatus.PICKED_UP

    def return_vehicle(self, reservation_id: str) -> None:
        """
        Mark a vehicle as returned for an active reservation.

        Changes the reservation status to COMPLETED and the vehicle status to AVAILABLE.
        Only reservations with ACTIVE status can be returned.

        Args:
            reservation_id (str): The unique ID of the reservation.

        Raises:
            TypeError: If reservation_id is not a string.
            ValueError: If reservation_id is empty, reservation is not found,
                or reservation status is not ACTIVE.
        """
        from schemas.entities import ReservationStatus, VehicleStatus

        # Validate reservation_id
        if not isinstance(reservation_id, str):
            raise TypeError("reservation_id must be a string.")
        if not reservation_id:
            raise ValueError("reservation_id cannot be empty.")

        # Find the reservation
        reservation = None
        for res in self.__reservations:
            if res.id == reservation_id:
                reservation = res
                break

        # Check if reservation exists
        if reservation is None:
            raise ValueError("Reservation with the given ID is not found.")

        # Check if vehicle can be returned
        if reservation.status != ReservationStatus.PICKED_UP.value:
            raise ValueError("Only active reservations can be returned.")

        # Update reservation status to COMPLETED
        reservation.status = ReservationStatus.COMPLETED

        # Update vehicle status to AVAILABLE
        reservation.vehicle.status = VehicleStatus.AVAILABLE

    @staticmethod
    def make_creditcard_payment(
        reservation: "Reservation", card_number: str, cvv: str, expiry: str
    ):
        """
        Make payment for a reservation with creditcard.

        Args:
            reservation (Reservation): Reservation object.
            card_number (str): Credit card number.
            cvv (str): Card CVV code.
            expiry (str): Card expiry date.

        Raises:
            TypeError: If reservation is not a Reservation object.
            ValueError: If reservation status is not APPROVED.
        """
        # Validation
        from entities.reservation import Reservation

        if not isinstance(reservation, Reservation):
            raise TypeError("reservation must be a Reservation object.")

        if reservation.status != ReservationStatus.APPROVED.value:
            raise ReservationNotApprovedError(reservation.id)

        # Create payment
        from entities.payment import CreditCardPaymentCreator

        credit_card_payment_service = CreditCardPaymentCreator(
            card_number=card_number, cvv=cvv, expiry=expiry
        )

        # Execute payment
        receipt = credit_card_payment_service.execute_payment(reservation.total_price)

        # Change invoice status
        if "successful" in receipt:
            reservation.invoice.payment_completed()

        else:
            reservation.invoice.payment_failed()

        return receipt

    @staticmethod
    def make_paypal_payment(reservation: "Reservation", email: str, auth_token: str):
        """
        Make payment for a reservation with creditcard.

        Args:
            reservation (Reservation): Reservation object.
            email (str): PayPal account email.
            auth_token (str): PayPal authentication token.

        Raises:
            TypeError: If reservation is not a Reservation object.
            ValueError: If reservation status is not APPROVED.
        """
        # Validation
        from entities.reservation import Reservation

        if not isinstance(reservation, Reservation):
            raise TypeError("reservation must be a Reservation object.")

        if reservation.status != ReservationStatus.APPROVED.value:
            raise ValueError("Only approved reservations can be paid.")

        # Create payment
        from entities.payment import PaypalPaymentCreator

        credit_card_payment_service = PaypalPaymentCreator(
            email=email, auth_token=auth_token
        )

        # Execute payment
        receipt = credit_card_payment_service.execute_payment(reservation.total_price)

        # Change invoice status
        if "successful" in receipt:
            reservation.invoice.payment_completed()

        else:
            reservation.invoice.payment_failed()

        return receipt

    def get_role(self) -> str:
        """Returns role of the user in the application"""
        return "customer"

    def get_information(self) -> dict[str, Any]:
        """Returns a dictionary including all user information"""
        return {
            "first_name": self.first_name,
            "last_name": self.last_name,
            "gender": self.gender,
            "birth_date": self.birth_date,
            "email": self.email,
            "phone_number": self.phone_number,
            "address": self.address,
            "reservations": self.__reservations,
        }

    def __str__(self):
        """Returns a string representation of the customer"""
        return f"Customer(Name: {self.first_name.title()} {self.last_name.title()}, Gender: {self.gender.title()}, Role: {self.get_role().title()})"
